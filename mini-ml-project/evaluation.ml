(* 
                         CS 51 Final Project
                         MiniML -- Evaluation
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error in
   the interpreter *)
exception EvalError of string ;;
  
(* Exception for evaluator runtime, generated by an explicit `raise`
   construct in the object language *)
exception EvalException ;;

(*......................................................................
  Environments and values 
 *)

module type ENV = sig
    (* the type of environments *)
    type env
    (* the type of values stored in environments *)
    type value =
      | Val of expr
      | Closure of (expr * env)
   
    (* empty () -- Returns an empty environment *)
    val empty : unit -> env

    (* close expr env -- Returns a closure for `expr` and its `env` *)
    val close : expr -> env -> value

    (* lookup env varid -- Returns the value in the `env` for the
       `varid`, raising an `Eval_error` if not found *)
    val lookup : env -> varid -> value

    (* extend env varid loc -- Returns a new environment just like
       `env` except that it maps the variable `varid` to the `value`
       stored at `loc`. This allows later changing the value, an
       ability used in the evaluation of `letrec`. To make good on
       this, extending an environment needs to preserve the previous
       bindings in a physical, not just structural, way. *)
    val extend : env -> varid -> value ref -> env

    (* env_to_string env -- Returns a printable string representation
       of environment `env` *)
    val env_to_string : env -> string
                                 
    (* value_to_string ?printenvp value -- Returns a printable string
       representation of a value; the optional flag `printenvp`
       (default: `true`) determines whether to include the environment
       in the string representation when called on a closure *)
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : ENV =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    let empty () : env = []

    let close (exp : expr) (env : env) : value =
      Closure (exp, env) 

    let lookup (env : env) (varname : varid) : value =
      try !(List.assoc varname env) with 
        Not_found -> raise (EvalError "Not in env") 

    let extend (env : env) (varname : varid) (loc : value ref) : env =
      (varname, loc) :: List.remove_assoc varname env

    let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with 
      | Val exp -> "(" ^ exp_to_concrete_string exp ^ ")"
      | Closure (exp, env) -> 
          if printenvp then ("(" ^ exp_to_concrete_string exp ^ ")") ^ ", " ^ 
                            ("[" ^ env_to_string env ^ "]")
          else "(" ^ exp_to_concrete_string exp ^ ")"

    and env_to_string (env : env) : string =
      match env with 
      | [] -> "}"
      | (varname, loc) :: tl -> 
          "{" ^ varname ^ " -> " ^ value_to_string !loc ^ 
          (if tl = [] then "" else ", ") ^ env_to_string tl 
  end
;;

open Env ;;

(*......................................................................
  Evaluation functions

  Each of the evaluation functions below evaluates an expression `exp`
  in an environment `env` returning a result of type `value`. We've
  provided an initial implementation for a trivial evaluator, which
  just converts the expression unchanged to a `value` and returns it,
  along with "stub code" for three more evaluators: a substitution
  model evaluator and dynamic and lexical environment model versions.

  Each evaluator is of type `expr -> Env.env -> Env.value` for
  consistency, though some of the evaluators don't need an
  environment, and some will only return values that are "bare
  values" (that is, not closures). 

  DO NOT CHANGE THE TYPE SIGNATURES OF THESE FUNCTIONS. Compilation
  against our unit tests relies on their having these signatures. If
  you want to implement an extension whose evaluator has a different
  signature, implement it as `eval_e` below.  *)

(* The TRIVIAL EVALUATOR, which leaves the expression to be evaluated
   essentially unchanged, just converted to a value for consistency
   with the signature of the evaluators. *)
   
let eval_t (exp : expr) (_env : Env.env) : Env.value =
  (* coerce the expr, unchanged, into a value *)
  Env.Val exp ;;

(* The SUBSTITUTION MODEL evaluator -- to be completed *)
   
type type_env = | Sub | Dyn | Lex ;;

let exp_of_val (v : Env.value) : expr = 
  match v with 
  | Val exp 
  | Closure (exp, _) -> exp ;;

let rec eval_abstract (exp : expr) (env : Env.env) 
                      (env_type : type_env) : Env.value = 
  let eval_binop (op : binop) (e1 : expr) (e2 : expr) : expr = 
    match (op, e1, e2) with 
    | Plus, Num x1, Num x2 -> Num (x1 + x2)
    | Plus, _, _ -> raise (EvalError "Can't add two non-integers")
    | Minus, Num x1, Num x2 -> Num (x1 - x2)
    | Minus, _, _ -> raise (EvalError "Can't subtract two non-integers")
    | Times, Num x1, Num x2 -> Num (x1 * x2)
    | Times, _, _ -> raise (EvalError "Can't multiply two non-integers")
    | Equals, Num x1, Num x2 -> Bool (x1 = x2)
    | Equals, Bool x1, Bool x2 -> Bool (x1 = x2)
    | Equals, _, _ -> raise (EvalError "Can't compare two non-ints/bools")
    | LessThan, Num x1, Num x2 -> Bool (x1 < x2)
    | LessThan, _, _ -> raise (EvalError "Can't compare two non-ints") in
  let eval_unop (exp : expr) : expr = 
    match (Negate, exp) with 
    | Negate, Num x -> Num (~-x)
    | Negate, _ -> raise (EvalError "Can't negate non-integers") in
  let eval_exp (exp : expr) : Env.value = 
    eval_abstract exp env env_type in 
  let exp_of_eval (exp : expr) : expr = 
    exp_of_val (eval_exp exp) in
  match exp with 
  | Num _ 
  | Bool _ -> Val exp
  | Raise 
  | Unassigned -> raise EvalException
  | Var x -> if env_type = Sub then raise (EvalError "Unbound variable")
             else Env.lookup env x
  | Unop (_, exp_Q) -> 
      Val (eval_unop (exp_of_eval exp_Q))
  | Binop (op, exp_P, exp_Q) -> 
      let e_P = exp_of_eval exp_P in
      let e_Q = exp_of_eval exp_Q in
      Val (eval_binop op e_P e_Q) 
  | Conditional (e1, e2, e3) -> 
      (match exp_of_eval e1 with 
       | Bool true -> eval_exp e2
       | Bool false -> eval_exp e3
       | _ -> raise (EvalError "No boolean in conditional"))
  | Fun _ -> 
      if env_type = Lex 
      then Env.close exp env 
      else Val exp
  | Let (v, exp_P, exp_Q) -> 
      if env_type = Sub then eval_exp (subst v (exp_of_eval exp_P) exp_Q) 
      else 
        let ref_v_D = ref (eval_exp exp_P) in
        let updated_env = Env.extend env v ref_v_D in
        eval_abstract exp_Q updated_env env_type
  | Letrec (v, exp_P, exp_Q) -> 
      let val_v_D = eval_exp exp_P in
      if env_type = Sub then 
        let v_D = exp_of_val (val_v_D) in
        let new_v_D = Letrec (v, v_D, Var (v)) in
        let sub_v_D = subst v new_v_D v_D in
        eval_exp (subst v sub_v_D exp_Q)
      else if env_type = Dyn then 
        let ref_v_D = ref (val_v_D) in
        let updated_env = Env.extend env v ref_v_D in
        eval_abstract exp_Q updated_env env_type
      else 
        let ref_exp = ref (Env.Val Unassigned) in
        let env_x = Env.extend env v ref_exp in 
        ref_exp := (eval_abstract exp_P env_x env_type); 
        eval_abstract exp_Q env_x env_type
  | App (exp_P, exp_Q) -> 
      let e_P = exp_of_eval exp_P in
      let e_Q = exp_of_eval exp_Q in 
      if env_type = Lex then 
         (match eval_exp exp_P with 
          | Closure (Fun (x , exp_body), env_l) -> 
              let v_Q = eval_exp exp_Q in 
              let updated_env_l = Env.extend env_l x (ref v_Q) in 
              eval_abstract exp_body updated_env_l env_type
          | _ -> raise (EvalError "Can't apply function application"))
      else 
         (match e_P with 
          | Fun (x, exp) -> 
              if env_type = Sub 
              then eval_exp (subst x e_Q exp)
              else 
                let ref_e_Q = ref (eval_exp exp_Q) in
                let updated_env = Env.extend env x ref_e_Q in 
                eval_abstract exp updated_env env_type
          | _ -> raise (EvalError "Can't apply function application")) ;;

let eval_s (exp : expr) (env : Env.env) : Env.value =
  eval_abstract exp env Sub ;;
     
(* The DYNAMICALLY-SCOPED ENVIRONMENT MODEL evaluator -- to be
   completed *)
   
let eval_d (exp : expr) (env : Env.env) : Env.value =
  eval_abstract exp env Dyn ;;
       
(* The LEXICALLY-SCOPED ENVIRONMENT MODEL evaluator -- optionally
   completed as (part of) your extension *)
   
let eval_l (exp : expr) (env : Env.env) : Env.value =
  eval_abstract exp env Lex ;;

(* The EXTENDED evaluator -- if you want, you can provide your
   extension as a separate evaluator, or if it is type- and
   correctness-compatible with one of the above, you can incorporate
   your extensions within `eval_s`, `eval_d`, or `eval_l`. *)

let eval_e _ =
  failwith "eval_e not implemented" ;;
  
(* Connecting the evaluators to the external world. The REPL in
   `miniml.ml` uses a call to the single function `evaluate` defined
   here. Initially, `evaluate` is the trivial evaluator `eval_t`. But
   you can define it to use any of the other evaluators as you proceed
   to implement them. (We will directly unit test the four evaluators
   above, not the `evaluate` function, so it doesn't matter how it's
   set when you submit your solution.) *)
   
let evaluate = eval_l ;;
